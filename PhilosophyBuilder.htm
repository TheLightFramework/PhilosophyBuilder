<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>âœ¨ Lp Forge | The Light Philosophy Editor</title>
    <style>
      :root {
        --bg: #f8f9fa;
        --text: #1f2937;
        --gold: #eab308;
        --gold-light: #fef08a;
        --truth-col: #eff6ff;
        --maybe-col: #f0fdf4;
        --practice-col: #fff7ed;
        --border: #e5e7eb;
        --muted: #6b7280;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: var(--bg);
        color: var(--text);
        margin: 0;
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      /* HEADER */
      header {
        background: white;
        padding: 14px 20px;
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        gap: 14px;
        flex-wrap: wrap;
      }

      h1 {
        margin: 0;
        font-size: 1.1rem;
        display: flex;
        align-items: center;
        gap: 10px;
        white-space: nowrap;
      }
      .badge {
        background: var(--gold);
        color: white;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.8rem;
      }

      .controls {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      button {
        padding: 8px 14px;
        border: none;
        border-radius: 8px;
        font-weight: 650;
        cursor: pointer;
        transition: all 0.2s;
      }

      .btn-primary {
        background: var(--text);
        color: white;
      }
      .btn-primary:hover {
        background: #000;
      }

      .btn-gold {
        background: var(--gold);
        color: white;
      }
      .btn-gold:hover {
        background: #ca8a04;
      }

      .btn-outline {
        border: 1px solid #ccc;
        background: white;
        color: #555;
      }
      .btn-outline:hover {
        background: #eee;
      }

      .search {
        width: min(360px, 60vw);
        padding: 9px 12px;
        border: 1px solid #ddd;
        border-radius: 10px;
        font-family: inherit;
        box-sizing: border-box;
      }

      /* BOARD LAYOUT */
      .board {
        display: flex;
        flex: 1;
        padding: 18px;
        gap: 18px;
        overflow: hidden;
      }

      .column {
        flex: 1;
        background: white;
        border-radius: 12px;
        border: 1px solid var(--border);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        min-width: 240px;
      }

      .col-header {
        padding: 14px 14px;
        font-weight: 800;
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
      }

      .col-title {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .subrow {
        display: flex;
        align-items: center;
        gap: 10px;
        font-weight: 650;
        color: var(--muted);
        font-size: 0.78rem;
      }

      .count {
        background: #eee;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 0.8rem;
        white-space: nowrap;
      }

      .sort {
        border: 1px solid #ddd;
        border-radius: 10px;
        padding: 6px 8px;
        font-size: 0.8rem;
        background: white;
        color: #374151;
      }

      .col-t {
        border-top: 4px solid #3b82f6;
        background: var(--truth-col);
      }
      .col-m {
        border-top: 4px solid #22c55e;
        background: var(--maybe-col);
      }
      .col-p {
        border-top: 4px solid #f97316;
        background: var(--practice-col);
      }

      .card-list {
        flex: 1;
        overflow-y: auto;
        padding: 14px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      /* CARD STYLES */
      .card {
        background: white;
        padding: 12px;
        border-radius: 10px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        border: 1px solid transparent;
        cursor: pointer;
        transition: transform 0.1s, box-shadow 0.1s;
      }

      .card:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        border-color: var(--gold);
      }

      .card-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        font-size: 0.75rem;
        color: #6b7280;
        margin-bottom: 6px;
        font-weight: 750;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        border-radius: 999px;
        padding: 2px 9px;
        background: #f3f4f6;
        color: #374151;
        max-width: 65%;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .idpill {
        background: #111827;
        color: white;
        max-width: none;
      }

      .probpill {
        background: #dcfce7;
        color: #166534;
      }

      .card-text {
        font-size: 0.92rem;
        line-height: 1.45;
        color: #374151;
        white-space: pre-wrap;
      }

      /* MODALS */
      .modal-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(2px);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        padding: 14px;
        box-sizing: border-box;
      }

      .modal {
        background: white;
        padding: 22px;
        border-radius: 14px;
        width: min(540px, 100%);
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2);
      }

      .modal h2 {
        margin: 0 0 12px 0;
        font-size: 1.1rem;
      }

      .form-group {
        margin-bottom: 14px;
      }
      label {
        display: block;
        font-size: 0.85rem;
        font-weight: 750;
        margin-bottom: 6px;
        color: #555;
      }

      select,
      textarea,
      input {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 10px;
        font-family: inherit;
        box-sizing: border-box;
      }

      textarea {
        height: 130px;
        resize: vertical;
      }

      .grid2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }

      .modal-footer {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 18px;
        flex-wrap: wrap;
      }

      .muted {
        color: var(--muted);
        font-size: 0.85rem;
      }

      /* CATEGORY EDITOR */
      .cat-row {
        display: flex;
        gap: 10px;
        align-items: center;
        margin-bottom: 10px;
      }
      .cat-row input {
        flex: 1;
      }

      /* UTILS */
      .hidden {
        display: none;
      }

      @media (max-width: 980px) {
        .board {
          flex-direction: column;
          overflow-y: auto;
        }
        .column {
          min-height: 240px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>âš¡ Lp Forge <span class="badge" id="version">v1.2</span></h1>
      <div class="controls">
        <input
          class="search"
          id="searchInput"
          type="search"
          placeholder="Search (text, section, IDs)â€¦"
        />
        <input type="file" id="fileInput" hidden accept=".md,.txt" />
        <button
          class="btn-outline"
          onclick="document.getElementById('fileInput').click()"
        >
          ðŸ“¥ Import MD
        </button>
        <button class="btn-outline" onclick="openCategoryModal()">
          ðŸ—‚ Categories
        </button>
        <button class="btn-gold" onclick="addNewItem()">+ New Item</button>
        <button class="btn-primary" onclick="exportFile()">ðŸ“¤ Export MD</button>
      </div>
    </header>

    <div class="board">
      <!-- T COLUMN -->
      <div class="column col-t">
        <div class="col-header">
          <div class="col-title">
            <span>TRUTHS (T)</span>
            <div class="subrow">
              <span class="muted">Sort:</span>
              <select
                class="sort"
                id="sort-t"
                onchange="setSort('T', this.value)"
              ></select>
            </div>
          </div>
          <span class="count" id="count-t">0</span>
        </div>
        <div class="card-list" id="list-t"></div>
      </div>

      <!-- M COLUMN -->
      <div class="column col-m">
        <div class="col-header">
          <div class="col-title">
            <span>MAYBES (M)</span>
            <div class="subrow">
              <span class="muted">Sort:</span>
              <select
                class="sort"
                id="sort-m"
                onchange="setSort('M', this.value)"
              ></select>
            </div>
          </div>
          <span class="count" id="count-m">0</span>
        </div>
        <div class="card-list" id="list-m"></div>
      </div>

      <!-- P COLUMN -->
      <div class="column col-p">
        <div class="col-header">
          <div class="col-title">
            <span>PRACTICES (P)</span>
            <div class="subrow">
              <span class="muted">Sort:</span>
              <select
                class="sort"
                id="sort-p"
                onchange="setSort('P', this.value)"
              ></select>
            </div>
          </div>
          <span class="count" id="count-p">0</span>
        </div>
        <div class="card-list" id="list-p"></div>
      </div>
    </div>

    <!-- EDIT MODAL -->
    <div class="modal-backdrop" id="editModal">
      <div class="modal">
        <h2 id="modalTitle">Edit Item</h2>

        <div class="grid2">
          <div class="form-group">
            <label>Type</label>
            <select id="editType" onchange="toggleProbField()">
              <option value="T">T - Truth</option>
              <option value="M">M - Maybe</option>
              <option value="P">P - Practice</option>
            </select>
          </div>

          <div class="form-group">
            <label>Number (optional)</label>
            <input
              type="number"
              id="editNum"
              min="1"
              step="1"
              placeholder="e.g., 12"
            />
          </div>
        </div>

        <div class="form-group" id="probGroup" style="display: none">
          <label>Confidence (%)</label>
          <input type="number" id="editProb" min="0" max="100" value="95" />
        </div>

        <div class="form-group">
          <label>Section (Category)</label>
          <select id="editSection"></select>
        </div>

        <div class="form-group">
          <label>Content</label>
          <textarea id="editContent" placeholder="Write your Lightâ€¦"></textarea>
        </div>

        <div class="modal-footer">
          <button
            class="btn-outline"
            style="color: red; margin-right: auto"
            onclick="deleteItem()"
          >
            Delete
          </button>
          <button class="btn-outline" onclick="closeModal()">Cancel</button>
          <button class="btn-primary" onclick="saveItem()">Save</button>
        </div>
      </div>
    </div>

    <!-- CATEGORY MODAL -->
    <div class="modal-backdrop" id="catModal">
      <div class="modal">
        <h2>ðŸ—‚ Category Editor</h2>
        <p class="muted" style="margin-top: -4px">
          Rename, add, or delete sections. Deleting a section moves its items to
          <b>INTRODUCTION</b>.
        </p>

        <div id="catList"></div>

        <div class="modal-footer">
          <button class="btn-outline" onclick="addCategory()">
            + Add Category
          </button>
          <button class="btn-outline" onclick="closeCategoryModal()">
            Close
          </button>
        </div>
      </div>
    </div>

    <script>
      // --- DATA STATE ---
      let appState = {
        sections: [], // { name, content: [] }
        items: [], // { id, type, num, prob, content, sectionIndex, createdAt, sourceOrder }
        settings: {
          search: "",
          sort: { T: "numAsc", M: "probDesc", P: "numAsc" },
        },
      };

      let currentEditId = null;

      // --- INIT ---
      window.onload = () => {
        const saved = localStorage.getItem("LpForge_State_v12");
        if (saved) {
          appState = JSON.parse(saved);
        } else {
          // Ensure we always have an INTRODUCTION section
          appState.sections = [{ name: "INTRODUCTION", content: [] }];
        }

        // Wire search
        const s = document.getElementById("searchInput");
        s.value = appState.settings.search || "";
        s.addEventListener("input", (e) => {
          appState.settings.search = e.target.value || "";
          saveLocally();
          renderBoard();
        });

        // Populate sort options + set defaults
        populateSortSelects();
        renderBoard();
      };

      function populateSortSelects() {
        const optsCommon = [
          { value: "numAsc", label: "Number â†‘" },
          { value: "numDesc", label: "Number â†“" },
          { value: "sectionAsc", label: "Section Aâ†’Z" },
          { value: "sectionDesc", label: "Section Zâ†’A" },
          { value: "newest", label: "Newest first" },
          { value: "oldest", label: "Oldest first" },
        ];

        const optsM = [
          { value: "probDesc", label: "Confidence â†“ (default)" },
          { value: "probAsc", label: "Confidence â†‘" },
          ...optsCommon,
        ];

        const map = {
          T: { el: "sort-t", opts: optsCommon },
          M: { el: "sort-m", opts: optsM },
          P: { el: "sort-p", opts: optsCommon },
        };

        for (const k of ["T", "M", "P"]) {
          const sel = document.getElementById(map[k].el);
          sel.innerHTML = "";
          map[k].opts.forEach((o) => {
            const opt = document.createElement("option");
            opt.value = o.value;
            opt.textContent = o.label;
            sel.appendChild(opt);
          });
          sel.value =
            appState.settings.sort?.[k] || (k === "M" ? "probDesc" : "numAsc");
        }
      }

      function setSort(type, value) {
        appState.settings.sort[type] = value;
        saveLocally();
        renderBoard();
      }

      // --- PARSING ENGINE ---
      document
        .getElementById("fileInput")
        .addEventListener("change", function (e) {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = function (e) {
            parseMarkdown(e.target.result);
          };
          reader.readAsText(file);
        });

      function parseMarkdown(text) {
  // Reset
  appState.items = [];
  appState.sections = [{ name: "INTRODUCTION", content: [] }];
  let currentSectionIdx = 0;

  // Split by any newline format to handle Windows/Mac/Linux
  const lines = text.split(/\r?\n/);
  
  // UPDATED REGEX: Accepts lowercase [tmp] and uppercase [TMP]
  const axiomRegex = /^([TMPtmp])(\d+)?(\((\d+)\))?:\s*(.+)$/;
  const headerRegex = /^##\s+(.+)$/;

  let order = 0;

  lines.forEach((rawLine) => {
    // CLEANING: Remove whitespace and \r artifacts from both ends
    const line = rawLine.trim();
    if (!line) return; // Skip empty lines

    const headerMatch = line.match(headerRegex);

    if (headerMatch) {
      currentSectionIdx++;
      appState.sections.push({
        name: headerMatch[1].trim(),
        content: [],
      });
    } else {
      const axiomMatch = line.match(axiomRegex);

      if (axiomMatch) {
        // NORMALIZATION: Force UpperCase so the rest of the app works
        const type = axiomMatch[1].toUpperCase(); 
        const num = axiomMatch[2] ? parseInt(axiomMatch[2], 10) : null;
        const prob = axiomMatch[4] ? parseInt(axiomMatch[4], 10) : null;

        appState.items.push({
          id: Date.now() + Math.random(),
          type,
          num,
          prob,
          content: (axiomMatch[5] || "").trim(),
          sectionIndex: currentSectionIdx,
          createdAt: Date.now(),
          sourceOrder: order++,
        });
      } else {
        // Regular text buffer (push the cleaned line)
        appState.sections[currentSectionIdx]?.content?.push(line);
      }
    }
  });

  saveLocally();
  renderBoard();
}

      // --- FILTER + SORT ---
      function normalize(s) {
        return (s || "").toString().toLowerCase();
      }

      function matchesSearch(item, displayId) {
        const q = normalize(appState.settings.search);
        if (!q) return true;

        const secName =
          appState.sections[item.sectionIndex]?.name || "INTRODUCTION";
        const hay = [
          item.type,
          displayId,
          secName,
          item.content,
          item.prob != null ? item.prob.toString() : "",
          item.num != null ? item.num.toString() : "",
        ]
          .map(normalize)
          .join(" | ");

        return hay.includes(q);
      }

      function getSortedItems(type) {
        const sort =
          appState.settings.sort?.[type] ||
          (type === "M" ? "probDesc" : "numAsc");
        const items = appState.items.filter((i) => i.type === type);

        const secName = (idx) => normalize(appState.sections[idx]?.name || "");

        const byNumAsc = (a, b) => {
          const an = a.num == null ? Number.POSITIVE_INFINITY : a.num;
          const bn = b.num == null ? Number.POSITIVE_INFINITY : b.num;
          if (an !== bn) return an - bn;
          return (a.sourceOrder ?? 0) - (b.sourceOrder ?? 0);
        };

        const byNumDesc = (a, b) => {
          const an = a.num == null ? Number.NEGATIVE_INFINITY : a.num;
          const bn = b.num == null ? Number.NEGATIVE_INFINITY : b.num;
          if (an !== bn) return bn - an;
          return (a.sourceOrder ?? 0) - (b.sourceOrder ?? 0);
        };

        const byProbDesc = (a, b) => {
          const ap = a.prob == null ? -1 : a.prob;
          const bp = b.prob == null ? -1 : b.prob;
          if (bp !== ap) return bp - ap;
          return byNumAsc(a, b);
        };

        const byProbAsc = (a, b) => {
          const ap = a.prob == null ? 101 : a.prob;
          const bp = b.prob == null ? 101 : b.prob;
          if (ap !== bp) return ap - bp;
          return byNumAsc(a, b);
        };

        const bySectionAsc = (a, b) =>
          secName(a.sectionIndex).localeCompare(secName(b.sectionIndex)) ||
          byNumAsc(a, b);
        const bySectionDesc = (a, b) =>
          secName(b.sectionIndex).localeCompare(secName(a.sectionIndex)) ||
          byNumAsc(a, b);
        const byNewest = (a, b) => (b.createdAt ?? 0) - (a.createdAt ?? 0);
        const byOldest = (a, b) => (a.createdAt ?? 0) - (b.createdAt ?? 0);

        let sorted = [...items];
        if (sort === "numAsc") sorted.sort(byNumAsc);
        else if (sort === "numDesc") sorted.sort(byNumDesc);
        else if (sort === "probDesc") sorted.sort(byProbDesc);
        else if (sort === "probAsc") sorted.sort(byProbAsc);
        else if (sort === "sectionAsc") sorted.sort(bySectionAsc);
        else if (sort === "sectionDesc") sorted.sort(bySectionDesc);
        else if (sort === "newest") sorted.sort(byNewest);
        else if (sort === "oldest") sorted.sort(byOldest);
        else sorted.sort(byNumAsc);

        return sorted;
      }

      // Assign display numbers (keeps existing numbers; fills blanks without collisions)
      function computeDisplayNumbers(type, sortedItems) {
        const used = new Set(
          sortedItems.filter((i) => i.num != null).map((i) => i.num)
        );
        let next = 1;

        const map = new Map();
        sortedItems.forEach((item) => {
          if (item.num != null) {
            map.set(item.id, item.num);
          } else {
            while (used.has(next)) next++;
            map.set(item.id, next);
            used.add(next);
            next++;
          }
        });
        return map;
      }

      // --- RENDERING ---
      function renderBoard() {
        // Clear columns
        document.getElementById("list-t").innerHTML = "";
        document.getElementById("list-m").innerHTML = "";
        document.getElementById("list-p").innerHTML = "";

        // Ensure sections dropdown exists
        const select = document.getElementById("editSection");
        select.innerHTML = "";
        appState.sections.forEach((sec, idx) => {
          const opt = document.createElement("option");
          opt.value = idx;
          opt.textContent = sec.name;
          select.appendChild(opt);
        });

        // Render each column with filter/sort/search
        const counts = { T: 0, M: 0, P: 0 };
        const totals = {
          T: appState.items.filter((i) => i.type === "T").length,
          M: appState.items.filter((i) => i.type === "M").length,
          P: appState.items.filter((i) => i.type === "P").length,
        };

        ["T", "M", "P"].forEach((type) => {
          const sorted = getSortedItems(type);
          const displayNums = computeDisplayNumbers(type, sorted);

          sorted.forEach((item) => {
            const displayId = `${type}${displayNums.get(item.id)}`;
            if (!matchesSearch(item, displayId)) return;

            const card = createCardElement(item, displayNums.get(item.id));
            document
              .getElementById(`list-${type.toLowerCase()}`)
              .appendChild(card);
            counts[type]++;
          });
        });

        // Update counts as shown/total
        document.getElementById(
          "count-t"
        ).textContent = `${counts.T}/${totals.T}`;
        document.getElementById(
          "count-m"
        ).textContent = `${counts.M}/${totals.M}`;
        document.getElementById(
          "count-p"
        ).textContent = `${counts.P}/${totals.P}`;

        // Keep sort selects aligned with settings
        document.getElementById("sort-t").value =
          appState.settings.sort?.T || "numAsc";
        document.getElementById("sort-m").value =
          appState.settings.sort?.M || "probDesc";
        document.getElementById("sort-p").value =
          appState.settings.sort?.P || "numAsc";
      }

      function createCardElement(item, displayNum) {
        const el = document.createElement("div");
        el.className = "card";
        el.onclick = () => openEditModal(item.id);

        const secName =
          appState.sections[item.sectionIndex]?.name || "INTRODUCTION";

        const idLabel = `${item.type}${displayNum}`;
        const prob =
          item.type === "M"
            ? item.prob != null
              ? `${item.prob}%`
              : "â€”%"
            : null;

        const rightPills = [
          `<span class="pill idpill">${idLabel}</span>`,
          item.type === "M" ? `<span class="pill probpill">${prob}</span>` : "",
        ].join("");

        el.innerHTML = `
          <div class="card-meta">
            <span class="pill" title="${secName}">${secName}</span>
            <span style="display:flex; gap:8px; align-items:center;">${rightPills}</span>
          </div>
          <div class="card-text">${escapeHtml(item.content)}</div>
        `;
        return el;
      }

      function escapeHtml(str) {
        return (str || "").replace(
          /[&<>"']/g,
          (m) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#039;",
            }[m])
        );
      }

      // --- EDITING LOGIC ---
      const modal = document.getElementById("editModal");

      function openEditModal(id) {
        currentEditId = id;
        const item = appState.items.find((i) => i.id === id);

        document.getElementById("modalTitle").textContent = "Edit Item";
        document.getElementById("editType").value = item.type;
        document.getElementById("editNum").value =
          item.num != null ? item.num : "";
        document.getElementById("editProb").value =
          item.prob != null ? item.prob : 95;
        document.getElementById("editContent").value = item.content || "";
        document.getElementById("editSection").value = item.sectionIndex ?? 0;

        toggleProbField();
        modal.style.display = "flex";
      }

      function addNewItem() {
        currentEditId = null;
        document.getElementById("modalTitle").textContent = "New Light";
        document.getElementById("editType").value = "T";
        document.getElementById("editProb").value = 95;
        document.getElementById("editNum").value = "";
        document.getElementById("editContent").value = "";
        document.getElementById("editSection").value = Math.min(
          1,
          appState.sections.length - 1
        );

        toggleProbField();
        modal.style.display = "flex";
      }

      function toggleProbField() {
        const type = document.getElementById("editType").value;
        document.getElementById("probGroup").style.display =
          type === "M" ? "block" : "none";
      }

      function closeModal() {
        modal.style.display = "none";
      }

      function saveItem() {
        const type = document.getElementById("editType").value;
        const probRaw = document.getElementById("editProb").value;
        const numRaw = document.getElementById("editNum").value;
        const content = document.getElementById("editContent").value || "";
        const sectionIdx = parseInt(
          document.getElementById("editSection").value,
          10
        );

        const num = numRaw === "" ? null : Math.max(1, parseInt(numRaw, 10));
        const prob =
          type === "M"
            ? probRaw === ""
              ? null
              : Math.min(100, Math.max(0, parseInt(probRaw, 10)))
            : null;

        if (currentEditId) {
          const item = appState.items.find((i) => i.id === currentEditId);
          item.type = type;
          item.num = num;
          item.prob = prob;
          item.content = content.trim();
          item.sectionIndex = sectionIdx;
        } else {
          appState.items.push({
            id: Date.now() + Math.random(),
            type,
            num,
            prob,
            content: content.trim(),
            sectionIndex: sectionIdx,
            createdAt: Date.now(),
            sourceOrder: appState.items.length,
          });
        }

        closeModal();
        saveLocally();
        renderBoard();
      }

      function deleteItem() {
        if (confirm("Extinguish this Light?")) {
          appState.items = appState.items.filter((i) => i.id !== currentEditId);
          closeModal();
          saveLocally();
          renderBoard();
        }
      }

      function saveLocally() {
        localStorage.setItem("LpForge_State_v12", JSON.stringify(appState));
      }

      // --- CATEGORY EDITOR ---
      const catModal = document.getElementById("catModal");

      function openCategoryModal() {
        renderCategoryEditor();
        catModal.style.display = "flex";
      }

      function closeCategoryModal() {
        catModal.style.display = "none";
        saveLocally();
        renderBoard();
      }

      function renderCategoryEditor() {
        const wrap = document.getElementById("catList");
        wrap.innerHTML = "";

        appState.sections.forEach((sec, idx) => {
          const row = document.createElement("div");
          row.className = "cat-row";

          const input = document.createElement("input");
          input.value = sec.name;
          input.placeholder = "Category nameâ€¦";
          input.oninput = () => {
            appState.sections[idx].name = input.value || sec.name;
            // keep section dropdown live
            saveLocally();
          };

          const del = document.createElement("button");
          del.className = "btn-outline";
          del.textContent = idx === 0 ? "Pinned" : "Delete";
          del.disabled = idx === 0;

          del.onclick = () => deleteCategory(idx);

          row.appendChild(input);
          row.appendChild(del);
          wrap.appendChild(row);
        });
      }

      function addCategory() {
        const name = prompt("New category name:");
        if (!name) return;
        appState.sections.push({ name: name.trim(), content: [] });
        saveLocally();
        renderCategoryEditor();
      }

      function deleteCategory(idx) {
        if (idx === 0) return;
        const name = appState.sections[idx]?.name || "this category";
        if (!confirm(`Delete "${name}"? Items will be moved to INTRODUCTION.`))
          return;

        // Move items to INTRODUCTION
        appState.items.forEach((it) => {
          if (it.sectionIndex === idx) it.sectionIndex = 0;
          else if (it.sectionIndex > idx) it.sectionIndex -= 1; // shift down
        });

        // Remove section
        appState.sections.splice(idx, 1);

        saveLocally();
        renderCategoryEditor();
      }

      // --- EXPORT LOGIC (The Re-Compiler) ---
      function exportFile() {
        let output = [];

        // Export uses current sorts (so "default sort by number / confidence" is honored)
        const types = ["T", "M", "P"];

        // Build items-by-section, but within each section keep sorted order per type
        const perTypeSorted = {};
        types.forEach((t) => {
          // Always export sorted by Number Ascending to keep the file logical
          const oldSort = appState.settings.sort?.[t];
          appState.settings.sort[t] = "numAsc";
          const sorted = getSortedItems(t);
          appState.settings.sort[t] = oldSort; // Restore UI state
          const displayNums = computeDisplayNumbers(t, sorted);
          perTypeSorted[t] = sorted.map((it) => ({
            ...it,
            _exportNum: displayNums.get(it.id),
          }));
        });

        // For each section: write header, content, then all items in that section
        appState.sections.forEach((section, sIdx) => {
          if (sIdx > 0) output.push(`## ${section.name}`);

          if (section.content && section.content.length > 0) {
            output.push(section.content.join("\n"));
          }

          // Collect items for this section in the order: T then M then P (each already sorted)
          const sectionItems = [];
          ["T", "M", "P"].forEach((t) => {
            perTypeSorted[t].forEach((it) => {
              if (it.sectionIndex === sIdx) sectionItems.push(it);
            });
          });

          if (sectionItems.length > 0) {
            output.push("");
            sectionItems.forEach((item) => {
              let prefix = "";
              if (item.type === "T") prefix = `T${item._exportNum}`;
              if (item.type === "P") prefix = `P${item._exportNum}`;
              if (item.type === "M") {
                const pr = item.prob != null ? item.prob : 50;
                prefix = `M${item._exportNum}(${pr})`;
              }
              output.push(`${prefix}: ${item.content}`);
            });
            output.push("");
          }
        });

        const finalString = output.join("\n").replace(/\n{3,}/g, "\n\n");

        const blob = new Blob([finalString], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "light-philosophy-QUANTIFIED_FORGED.md";
        a.click();
      }
    </script>
  </body>
</html>
